1.项目思路
熟悉项目的各个目录

拆分组件(普通组件和路由组件)
普通组件---components中
路由组件---pages中(在公司中可能会放在其他的目录中)
特殊情况: 有一些非路由组件(普通组件)也可能会出现在路由组件的目录中
封装高级复用组件
1. 结构和样式
2. 设计数据
3. 和父级组件是否有通信的操作(子级组件分发事件,通知父级组件做相关的操作)
路由器,注册路由 路由守卫
路由器: 管理多个路由组件的对象,内部封装了很多的路由组件,同时可以设置在浏览器的地址栏中显示的时候地址是否携带#
路由在跳转的时候,可以设置跳转到的页面的位置
在实例化路由器对象的之前,可以重新push和replace方法---新的路由对象中有bug,编程式路由在跳转的时候,如果多次的点击跳转地址,会报错
路由守卫:
全局路由守卫和路由独享守卫和组件内守卫
全局路由守卫:是在创建router后,暴露之前进行创建,对多个路由地址要进行判断操作,或者跳转操作
路由独享守卫:是在注册路由组件中,一般对某个路由进行跳转操作
组件内守卫: 针对某个路由组件跳转进行操作,注意:组件内前置守卫,内部是不能直接使用this组件实例对象,需要通过next(vm=>{vm就是当前组件实例对象})
Vuex: 项目中是否使用vuex,取决于公司的领导
state:状态数据的
mutations:直接修改状态数据(同步)
actions:间接修改状态数据(异步或者同步)
getters:和状态数据相关的计算属性(get)
modules:上面的四个对象都可以在modules中使用

api  拦截器(请求拦截器和响应拦截器) index.js---封装api接口函数
mock----拦截ajax请求,生成随机数据的


前后端交互的流程思路:
1. 后台会给前端程序员一个api接口文档(如果一开始或者中途有些接口并没有提供,此时使用mockjs的方式自己设计数据模拟前后台交互操作)
2. 通过postMan工具测试接口或者通过swagger在线测试接口工具  进行接口的测试
 请求方式:get,post.delete.... 注意
 参数: 携带,raw选项找JSON的方式(键值对的写法)
3. 先在api目录的index.js中封装api接口函数---->为了方便在程序中发送异步请求
    请求拦截器: 如果涉及到该接口需要用户临时凭证,那么需要进行携带,如果需要登录后才能访问的接口,需要携带token,其他的暂时不用
    响应拦截器: 主要就是返回响应的数据及错误的处理方式
4. 如果使用了vuex,那么就在vuex中封装state,mutations,actions,getters, 
 如果没有使用vuex,一般会在main.js文件中通过为Vue的原型添加属性的方式保存暴露出来的api接口函数
 如: Vue.prototype.$API = API ----例子   目的:方便项目中任意的一个组件可以直接调用api接口函数进行异步的操作
5. 在组件内部提交action,  this.$store.dispatch('action的名字')
6. 通过计算属性获取 状态数据(简便写法)  
   mapState,mapGetters,mapMutations,mapActions
7. 组件内部使用状态数据进行遍历,修改,或者一些其他的操作
 












