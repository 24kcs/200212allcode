/**
 * 
 * 如果在Vue中发送异步请求
 * 1) vue-resource,在main.js中引入,声明使用插件
 * 2) axios,可以直接在某个组件引入即可使用
 * 
 * vue-router
 * Vue的路由器,实现单页面应用----
 * 单页面应用:只有一个页面,页面在不刷新的情况下(不跳转到新的页面),仍然可以有不同页面的效果(不同组件的切换既可显示不同页面的效果)
 * 单页面应用:简称:SPA------Vue-Router可以让开发SPA更加的简单方便
 * 路由器:管理多个路由的
 * 路由:前端路由：就是一种映射关系,链接地址对应着某个组件,跳转地址,则对应的组件内容就会显示出来
 * 链接地址:就叫路由链接
 * 路由链接:就是一个用a标签,并且设置了href属性所产生的链接地址
 * 路由视图:就是这个路由链接地址对应的这个组件最终显示出来的效果
 * 
 * 路由链接:<router-link>--->最终在页面中会产生一个a标签,里面的href中有地址,点击该地址就会显示这个地址对应的组件内容
 * 路由视图:<router-view>--->最终在页面中显示的是某个组件中的内容
 * 
 * 组件的不同叫法；
 * 普通组件和路由组件
 * 普通组件:在其他组件内引入,当成标签使用即可
 * 路由组件:普通组件一旦通过路由进行注册了(有个路由的链接地址,和当前的这个普通组件形成了映射关系),那么此时这个普通组件的叫法就改变了,就叫路由组件
 * 
 * 普通组件一般放在components目录中
 * 路由组件一般放在pages目录中,到了公司中有可能会改变名字
 * 
 * 使用vue-router实现单页面应用SPA开发,那么需要先安装vue-router,并且注册路由,最终再注册路由器,最终再在页面中使用router-link和router-view即可实现单页面应用开发
 * 
 * 首先路由的使用的步骤:
 * router目录,index.js文件
 * 1. 引入vue-router-----要进行路由器的创建,并暴露
 * 2. 内部需要注册路由
 * 3. 在main.js中引入路由器,并注册路由器
 * 
 * 路由:分为多个级别:
 * 一级路由:地址中只有一个路径  如: /about
 * 二级路由:地址中有多个路径  如:/home/news
 * 三级路由: 如:/home/message/detail
 * ...多级路由
 * 
 * 子路由:当前路由下还有其他的路由
 * 
 * 
 * 路由的重定向:界面打开后默认的跳转到指定的路由链接地址,显示对应的组件内容,或者跳转到某个路由链接对应的组件的时候,自动的跳转到下一级的路由地址
 * 
 * 
 * 声明式路由:通过html的方式(非js的代码)在页面中能够实现点击路由链接,跳转到该路由链接地址对应的组件内容中,并显示出来
 * 编程式路由:通过js代码的方式,实现路由链接跳转,显示对应组件
 * 
 * 路由跳转,可以携带参数(query方式传参,还有params的方式传参,暂且先知道有这么两种方式即可,还有其他的方式及该如何传参,先不说)
 * 
 * 一旦路由器注册成功后(main.js文件中注册了router),那么每个组件的实例对象中都会出现两个对象
 * $router对象:路由器对象,可以调用路由器相关的方法
 * $route对象:路由信息对象,可以调用路由跳转的时候里面的相关的属性获取信息数据
 * 
 * router-link 配合router-view 种方式可以直接实现路由跳转，及传递参数,和显示对应的路由组件内容，并不是通过js代码来实现的,这种方式实现路由跳转,称为:声明式路由
 * 路由的方式:声明式路由和编程式路由
 * 声明式路由:直接使用router-link配合router-view的方式实现路由跳转
 * 编程式路由:通过js代码的方式来实现路由的跳转
 * 编程式路由需要通过$router对象来进行实现
 * push()方法和replace()方法,back()方法
 * 
 * 
 * push()方法和replace()方法都可以实现路由跳转,区别呢
 * router-link 声明式路由跳转和push()方法效果一样,都带有历史记录,所以,使用router.back()方法都可以返回上一次跳转的位置
 * replace()方法跳转的时候,可以认为没有历史记录,直接返回初始的状态
 * 
 * router-link也想向replace的跳转方式一样,该怎么办
 * 直接使用replace属性即可
 * 
 * 
 * 路由在跳转的过程中,链接地址发生变化,原来链接地址对应的显示的这个组件就会消失(被销毁),
 * 路由在跳转的时候,能否让跳转前的那个路由组件继续的存活下去,可以,使用缓存的组件进行缓存
 * <keep-alive>进行包裹
 * 
 * 
 * 通过router-view标签可以向某个组件内传递数据,但是需要使用props进行接收
 * 
 * 
 * Vuex是一个专为 Vue.js 应用程序开发的状态管理模式,也是一个状态管理工具
 * Vuex是一个集中式管理状态数据的一个工具,可以对组件内的状态数据进行统一的管理操作
 * npm install vuex --save
 * 引入并暴露vuex对象,并注册
 * 
 * 1. 一般会在src中单独的创建一个目录(可以是vuex目录,也可以是store目录)
 * vuex目录,里面会有一个store.js文件-----仅仅是一种规范,或者习惯
 * store目录,里面会有一个index.js目录-----仅仅是一种规范,或者习惯
 * 以上不是必须的
 * 
 * 创建Vuex的实例对象(仓库对象),并暴露出去,在main.js注册仓库对象
 * 
 * Vuex中一共有5个对象,我们现在讲4个,第五个讲项目的时候讲
 * state对象:管理状态数据
 * mutations对象:直接修改状态数据
 * actions对象:间接修改状态数据
 * getters对象:状态数据的计算属性
 * 
 * 如果是状态数据,那么扔进state对象中
 * 如果有相关的方法操作状态数据,该方法丢进mutations中
 * 如果该方法是异步的操作并且和状态数据有关系,丢到actions中,当然,同步的操作也可以
 * 如果该状态数据有相关的计算属性,扔进getters对象中
 * 
 * mutations对象中的方法可以直接修改状态数据,需要什么状态数据,直接传入即可
 * actions对象中的方法不能直接修改状态数据,如果要修改状态数据,必须通过mutation
 * 
 * 自己的理解: actions中的每个函数都是action,action方法要修改状态数据,需要传入一个context对象,context对象可以访问state,也可以访问getter
 * 通过context对象调用commit('mutation')用来提交mutation---可以访问mutation了
 * 
 * 
 * 
 * 官方说法:
 * Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters
 * 
 * 
 * 
 * 
 * 
 * Vue是单向数据流，可以有双向数据绑定,但是双向数据绑定不是双向数据流
 * 
 * 
 * 
 */