/**
 * 1. 通过脚手架3下载项目模版
 * 2. package.json 文件中设置 --open
 * 3. 干掉src目录中没用的文件
 * 4. 设置App.vue中的样式是通过less的方式设置
 * 5. 下载相关的插件 npm install vue-router axios vuex less less-loader
 * 6. 在src目录中新建一些目录
 * api----存储axios 用来做异步操作的相关的文件(index.js----api的接口函数----ajax.js----封装请求拦截器和响应拦截的)
 * components---普通组件的
 * mock----mockjs的文件的
 * pages----路由相关的组件
 * router----路由的注册及配置的
 * utils----封装的工具函数或者对象
 * store----vuex
 * 
 * 
 * 7. 拆分静态页面,Header组件和Footer组件两个普通组件
 *  中间主体的部分---Home组件----路由组件
 * 
 * 8. 编程式路由进行跳转,push方法或者replace方法出现bug的解决方式:
 * 
 * 
 * 9. 编程式路由跳转并传递参数的不同写法
 * params:首先需要在注册路由组件的时候,设置:keyword进行占位
 * this.$router.push(`/search/${this.keyword}`)    字符串的写法
 * 
 * query:注册路由的时候,正常的写法,不需要设置:进行占位
 *  this.$router.push(`/search?keyword=${this.keyword}`)   字符串的写法
 * params 传参可以使用对象的写法:
 *  需要在注册路由组件的时候,占位,同时设置name属性
 *  this.$router.push({ name: 'search', params: { keyword: this.keyword } })
 * query 传参可以使用对象的写法:
 *  需要在注册路由组件的时候, 不用占位,也不用设置name属性
 *  this.$router.push({path:'/search',query:{keyword:this.keyword}})
 * 总结:query的对象写法中也可以使用name属性的方式,但是params的对象写法中不可以使用path的属性的方式的
 * 
 * 
 * 跨域:
 * 通过脚手架启动项目的时候,默认会有一个服务器,以localhost:8081 这种形式打开当前页面,想要通过一部请求访问另一个服务器的地址获取相关的数据,此时是当前浏览器想和另一个服务器进行交互,出现了无法正常访问的问题(服务器和服务器不存在跨域问题,当前的浏览器用到了当前的服务器,浏览器和另一个服务器的交互的问题)
 * 通过webpack的使用正向代理的方式来解决跨域
 * 正向代理是当前的服务器代理的是当前的浏览器(客户端)向另一个服务器发送请求
 * 反向代理是客户端访问某个服务器获取相关的数据操作(类似于这样的操作,交互行为),此时你访问的服务器并不是真正的服务器,而是一个代理的这个服务器,这个服务器代理的是真正的服务器
 * 
 * 脚手架3中的跨域问题
 * 在vuex.config.js文件中进行配置devServer对象中配置
 * 脚手架2中的跨域问题
 * 在config目录中的,index.js文件中的,proxyTable:{}对象中进行跨域的配置
 * 脚手架2/3中的eslint语法检查的配置
 * 脚手架2中: 在.eslintignore文件中或者eslintrc.js中对eslint语法进行关闭操作
 * 脚手架3中: 在package.json中的"rules": {} 关闭相关的eslint语法检查,或者在vue.config.js文件中进行配置的方式关闭eslint语法检查
 * 
 * 
 * 
 * 在组件内部通过调用api接口函数,获取服务器响应回来的数据,有可能会在其他的组件中使用,涉及到组件之间通信的问题
 * 任意组件之间进行传递数据----组件之间的通信
 * 事件总线,消息订阅,Vuex----
 * 
 * 
 * Vuex的模块化操作的原因:将来有很多的状态数据,会让实例化Vuex.Store()的时候内部的这个中代码显得很臃肿
 * Vuex中一共实际上有5个对象,state,mutations,actions,getters ,但是还有一个是modules---Vuex的模块化操作
 * 每个模块中都可以有Vuex中前面的四个对象,最终把这个四个对象一起暴露出来,然后在modules对象中引入即可,就形成了Vuex的模块化操作
 * 为了方便统一管理Vuex中的这些状态数据,并且和原来的state,mutations,actions,getters不冲突的情况下,采用了modules模块化操作,最外面的state,mutations,actions,getter这些都可以叫总的,什么意思?
 * 总的  这些可以删除,但是也可以不删除
 * state----总的state
 * mutations---总的mutations
 * ations---总的actions
 * getters---总的getters
 * 
 * vuex中有什么样的对象,modules对象中就可以有什么对象-----
 * 
 * 
 * 
 * 模块中的state,mutations,actions,getters,这些都是模块中的
 * 1)Vuex模块化后数据该如何的获取
 * this.$store.总的state.模块的名字.状态数据
 * this.$store.state.home.baseCategoryList---获取数据
 * 在组件内部的一些方法中通过js代码的方式来获取
 * 在组件内部的html模版中如何获取?----先通过计算属性的方式来获取,然后再使用
 * 首先引入Vuex的辅助函数,然后通过计算属性
 *  baseCategoryList:state对象=>state对象.home模块.baseCategoryList
 * 2)举例:总的actions中有个showMsg方法,某个模块中也有一个showMsg的方法,相同的方法该如何的使用
 * 先调用的是总的actions中的方法,然后再调用模块中的actions中的方法
 * 先总后模块,先找总的actions中的这个方法,如果没有则好模块中的actions中的方法,如果模块中也没有则报错
 * 
 * 
 * ==================================
 * 
 * 问题1: 点击分类信息跳转到search界面,同时传递参数
 * /search?categoryName=手机&category1Id=2
 * /search?categoryName=手机通讯&category2Id=13
 * /search?categoryName=酒柜&category3Id=99
 * 
 * 每次点击不同分类信息 跳转到search界面
 * 必然传入一个categoryName的数据,和 category1Id  ||  category2Id   ||   category3Id
 * categoryName和(1||2||3)的id值
 * 
 * 通过router-link的方式实现了路由跳转及传递参数数据,但是产生了大量的router-link,页面出现了卡顿的效果=====
 * 解决:继续使用以前的a标签的方式,但是不需要为所有的a标签绑定点击事件监听,原因是如果这么作为(所有的a都绑定点击事件,还是会造成大量的a绑定事件,造成代码的冗余,主要的问题是:vue在渲染的过程中大量绑定事件，渲染的效率还是很低),通过事件委托的方式只为最外层的div绑定点击事件,其他标签的点击操作也会触发该点击事件。最终是希望只点击a标签才实现跳转,如何解决呢?
 * 
 * 
 * 
 * 
 * 问题2: 分类列表,鼠标进入的时候,此时该事件可以被触发n次-----没有必要====函数的防抖或者节流的方式
 * 采用函数节流的方式来解决该问题
 * 引入lodash插件,调用内部的throttle方法使用函数节流(实现了按需引入的方式来优化代码)
 * 
 * 希望在标签中存储数据
 * 在标签中自定义属性来存储数据
 * <p index="10"></p>
 * 通过js来获取的时候 DOM的p对象.getAttribute('index')---->该属性的值
 * HTML5中为了方便获取自定义属性存储的数据
 * <p data-index="10"></p>
 * 通过js来获取的时候  DOM的p对象.dataset对象---->index属性的值
 * dataset的方式,里面的属性都会变成小写的
 * 
 * 
 * 每次进入到一个新的界面后,只要该界面中有TypeNav组件,那么就会发送一次异步请求,重新获取分类信息数据
 * 该分类信息数据,只获取一次就足够了,
 * 优化异步请求的操作
 * 
 * 
 * 目的:搞定轮播图
 * 设计数据json
 * mockjs
 * swiper
 * 拆分组件---全局公共组件
 * 实现轮播图
 * 
 * 
 * 
 * ==========================================
 * 第三天
 * 
 * 1. 分析ListContainer组件和Floor组件内部都有轮播图
 * 1)轮播图的数据应该是动态的数据
 * 在组件内部调用异步action,发送请求,获取轮播图的数据,组件内通过vuex获取响应回来的数据,动态的显示到页面中
 * 2)Floor组件内部的数据也是动态的数据
 * 在组件内部调用异步action,发送请求,获取Floor的相关数据,组件内通过vuex获取响应回来的数据,动态的显示到页面中
 * 
 * 组件内动态的获取数据----->调用异步action---->vuex中应该有状态数据----->调用接口函数--->发送请求----api函数----后台提供api接口----对应的数据
 * 
 * 
 * 
 * 目的:获取数据展现在页面中
 * 目前:
 * 现在没有轮播图的数据,也没有floor的数据
 * 
 * 前端程序员 ---->调用接口函数----->后台程序员提供api接口
 * 
 * 项目---前端程序员和后台程序员配合开发出来
 * 
 * 设计数据---->调用接口--->发送请求---获取数据,显示到页面中==========
 * 
 * 自己设计数据(最后和后台肯定是吻合的)
 * 
 * 经典的面试题： 自己实现登录操作,帐号:admin,密码88888 ,帐号和密码如果正确则跳转显示登录成功,否则提示帐号或者密码错误(搭建服务器,设计数据,通过脚手架2/3的进行搭建项目,自己搭建界面,实现异步操作,路由组件的注册)
 * 
 * 
 * 设计数据,主要参考平时调用接口返回的数据,进行设计
 * 设计数据------>js中存储---->number,string,boolean,array,object
 * 最方便的方式来存储数据的类型,应该是array或者object
 * 存储数据的文件:.json文件
 * 不知道存储多少个数据,用数组来存储
 * 一般情况为了数据操作起来方便,使用对象来存储数据
 * .json文件----->[{},{},{}]
 * 
 * 轮播图的数据设计方式
 * [
 *    
 *    
 *   {
 *     'id':'1',
 *      imrUrl:'./images/1.jpg'
 *   }
 * ]
 * 不可以修改      可以修改
 *    键      :     值
 * 键----结构的类型---不能被随便修改的
 * 键---结构类型
 * 值---结构的值
 *   "id":"1",
 *   "imgUrl":"./images/1.jpg"
 * 
 * 楼层的数据
 * 
 * {
 *   "title":"家用电器",
 *   "keywords":[
 *     {
 *       "keyword":"节能补贴",
 *       "id":"1",
 *       "url":"http://localhost:8080"
 *     },
 *     {
 *       "keyword":"节能补贴",
 *       "id":"1",
 *       "url":"http://localhost:8080"
 *     }
 *   ]
 * }
 *
 * 
 *  
 * 
 * 设计数据---->调用接口--->发送请求---获取数据,显示到页面中==========
 * 数据---在本地----调用接口--->设计接口
 * 如果把本地的数据,通过接口的方式来获取
 * 
 * 
 * 最终 ：步骤:
 * 组件内部提交action---->调用接口---->发送异步请求--->获取数据--->提交mutation--->更新Vuex中的状态数据--->组件内部通过Vuex获取数据--->遍历数据--->展现数据
 * Vuex管理banners数据和floors数据
 * 
 * 页面中的轮播图是没有效果,实现轮播图的效果,然后再遍历数据--->展现数据
 * 
 * ListContainer和Floor组件中都要展现轮播图的效果
 * 安装swiper插件,同时引入其样式文件
 * 复制swiper的html结构代码
 * 在页面加载后创建Swiper对象,并传入选择器及配置对象,打开页面后有轮播图的效果了
 * 此时展开页面有bug存在,卡或者连续漂浮的方式切换图片
 * 
 * 轮播图最外面的div的类样式的名字:swiper-container
 * 创建Swiper对象的时候,第一个参数的选择器:.swiper-container
 * Floor组件内部的轮播图的html结构中的类样式的名字:swiper-container
 * 
 * 在组件内部,通过计算属性的方式内部调用vuex辅助函数,获取banners数据后,页面中的轮播图挂了,不能正常的滑动,无法显示轮播图效果----bug
 * 
 * 在Vue中组件之间的关系父子关系(直接/间接),兄弟关系
 * 父子关系的组件,在页面中渲染的时候,应该是先把子级组件渲染出来,然后再渲染父级组件
 * Home组件是父级组件,ListContainer组件是子级组件
 * ListContainer组件内部应该先有swpier的html渲染完毕后,然后再创建Swiper对象,才有轮播图的效果
 * 现在:
 * 父级组件Home加载后才能发送异步请求,不太可能发完异步请求就可以直接获取了数据(发送请求的时候,过了一小会(时间很短)---数据就获取到了),而在Home父级组件渲染之前,子级组件ListContainer已经渲染完毕了,里面的Swiper对象也已经创建完了,但是数据还没有拿到,也就是说,swiper标签结构中的显示图片的标签因为是使用v-for的指令,数组中没有数据,此时标签不会被创建,但是swiper已经创建完了,此时再获取数据也已经没有效果了--------原因
 * 
 *  解决方式1:
 *  通过定时器,延迟Swiper对象的创建,可以的,但是,延迟多长时间是不能确定
 * 
 * 解决方式2:watch
 * 通过watch对象监视banners数据,一旦发生变化后,再去创建Swiper的对象
 * 使用watch监视数据,无非就是等到数据发生了变化,也就是DOM已经渲染完毕了,就创建Swiper的对象
 * 监视数据的过程中,只要数据发生了变化,DOM渲染了,那么就创建Swiper对象就可以实现轮播图的效果
 * 解决方式3: nextTick()方法/$nextTick()
 * .nextTick()是Vue的,$nextTick()是vm实例对象,用谁都可以调用
 * 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */